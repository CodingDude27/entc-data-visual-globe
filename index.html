<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Student Immigration Globe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap");

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0e1a; /* deep space dark */
      font-family: "Inter", -apple-system, BlinkMacSystemFont, system-ui,
        sans-serif;
      overflow: hidden;
      color: #ffffff;
    }

    #globe {
      width: 100vw;
      height: 100vh;
      cursor: grab;
      display: block;
    }

    #globe:active {
      cursor: grabbing;
    }

    /* Minimal control: pause / play */
    #controls {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 10;
    }

    #toggle-rotation {
      border: 1px solid rgba(59, 130, 246, 0.6);
      background: rgba(15, 23, 42, 0.85);
      color: #e5e7eb;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      backdrop-filter: blur(8px);
    }

    #toggle-rotation:hover {
      background: rgba(30, 64, 175, 0.9);
      color: #ffffff;
    }

    /* Countries */
    .country {
      fill: #1a2332;
      stroke: #2d3748;
      stroke-width: 0.5;
    }

    /* Base arc (thin) for subtle 3D / outline */
    .arc-base {
      fill: none;
      stroke-linecap: round;
      stroke-width: 0.6;
      opacity: 0.4;
    }

    /* Glowing static arc (main body) */
    .arc-main {
      fill: none;
      stroke-linecap: round;
    }

    /* Moving glow segment */
    .arc-glow {
      fill: none;
      stroke-linecap: round;
      opacity: 0.0; /* will be animated */
    }

    /* Volume bands (colors & widths) */

    /* High volume: red */
    .high-base {
      stroke: rgba(239, 68, 68, 0.4); /* #ef4444 */
    }
    .high-main {
      stroke: #ef4444;
      stroke-width: 2.5;
      opacity: 0.8;
    }
    .high-glow {
      stroke: rgba(239, 68, 68, 0.9);
      stroke-width: 4;
      filter: url(#glowRed);
    }

    /* Medium volume: blue */
    .med-base {
      stroke: rgba(59, 130, 246, 0.4); /* #3b82f6 */
    }
    .med-main {
      stroke: #3b82f6;
      stroke-width: 1.6;
      opacity: 0.75;
    }
    .med-glow {
      stroke: rgba(59, 130, 246, 0.9);
      stroke-width: 3;
      filter: url(#glowBlue);
    }

    /* Low volume: green */
    .low-base {
      stroke: rgba(16, 185, 129, 0.4); /* #10b981 */
    }
    .low-main {
      stroke: #10b981;
      stroke-width: 1.1;
      opacity: 0.7;
    }
    .low-glow {
      stroke: rgba(16, 185, 129, 0.9);
      stroke-width: 2.2;
      filter: url(#glowGreen);
    }
  </style>
</head>
<body>
  <!-- Minimal pause/play control -->
  <div id="controls">
    <button id="toggle-rotation">Pause rotation</button>
  </div>

  <svg id="globe"></svg>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/d3-geo.v3.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <script>
    // ==============================
    // CONFIGURATION & STATE
    // ==============================
    const width = window.innerWidth;
    const height = window.innerHeight;

    const config = {
      autoRotateSpeed: 0.005, // rad per ms
      verticalTilt: -10,
      horizontalTilt: 0,
    };

    let autoRotate = true;
    let migrationData = []; // full dataset from Retool
    let filteredData = []; // subset (e.g., filtered by country)
    let selectedCountry = null;

    const countryCoords = {
      Australia: [-25.27, 133.78],
      Canada: [56.13, -106.35],
      Finland: [61.92, 25.75],
      Germany: [51.17, 10.45],
      India: [20.59, 78.96],
      Ireland: [53.41, -8.24],
      Russia: [61.52, 105.32],
      "South Africa": [-30.56, 22.94],
      UAE: [23.42, 53.85],
      UK: [55.38, -3.44],
      USA: [37.09, -95.71],
    };

    // ==============================
    // SVG & PROJECTION
    // ==============================
    const svg = d3
      .select("#globe")
      .attr("width", width)
      .attr("height", height);

    const projection = d3
      .geoOrthographic()
      .scale(Math.min(width, height) / 2.1)
      .translate([width / 2, height / 2])
      .rotate([config.horizontalTilt, config.verticalTilt])
      .precision(0.5);

    const path = d3.geoPath().projection(projection);

    const sphere = { type: "Sphere" };

    // 3D-ish sphere: fill + gradient halo
    svg
      .append("defs")
      .append("radialGradient")
      .attr("id", "sphereGradient")
      .selectAll("stop")
      .data([
        { offset: "0%", color: "#111827" },
        { offset: "50%", color: "#111827" },
        { offset: "100%", color: "#020617" },
      ])
      .enter()
      .append("stop")
      .attr("offset", (d) => d.offset)
      .attr("stop-color", (d) => d.color);

    // Glow filters for arcs
    const defs = svg.append("defs");

    const makeGlow = (id, color) => {
      const filter = defs
        .append("filter")
        .attr("id", id)
        .attr("x", "-50%")
        .attr("y", "-50%")
        .attr("width", "200%")
        .attr("height", "200%");
      filter
        .append("feGaussianBlur")
        .attr("stdDeviation", 3)
        .attr("result", "coloredBlur");
      const feMerge = filter.append("feMerge");
      feMerge.append("feMergeNode").attr("in", "coloredBlur");
      feMerge.append("feMergeNode").attr("in", "SourceGraphic");
    };

    makeGlow("glowRed", "rgba(239,68,68,0.9)");
    makeGlow("glowBlue", "rgba(59,130,246,0.9)");
    makeGlow("glowGreen", "rgba(16,185,129,0.9)");

    // Draw sphere body
    svg
      .append("path")
      .datum(sphere)
      .attr("class", "sphere-fill")
      .attr("d", path);

    // Soft halo overlay
    svg
      .append("path")
      .datum(sphere)
      .attr("class", "sphere-glow")
      .attr("d", path);

    const countriesGroup = svg.append("g").attr("class", "countries");
    const arcsBaseGroup = svg.append("g").attr("class", "arcs-base");
    const arcsMainGroup = svg.append("g").attr("class", "arcs-main");
    const arcsGlowGroup = svg.append("g").attr("class", "arcs-glow");

    // ==============================
    // WORLD MAP
    // ==============================
    d3.json(
      "https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json"
    ).then((world) => {
      const countries = topojson.feature(world, world.objects.countries);

      countriesGroup
        .selectAll("path")
        .data(countries.features)
        .enter()
        .append("path")
        .attr("class", "country")
        .attr("d", path);
    });

    // ==============================
    // ARC HELPERS (volume -> style)
    // ==============================
    function classifyVolume(count) {
      if (count >= 500) return "high";
      if (count >= 100) return "med";
      return "low";
    }

    function arcClassBase(count) {
      const v = classifyVolume(count);
      if (v === "high") return "arc-base high-base";
      if (v === "med") return "arc-base med-base";
      return "arc-base low-base";
    }

    function arcClassMain(count) {
      const v = classifyVolume(count);
      if (v === "high") return "arc-main high-main";
      if (v === "med") return "arc-main med-main";
      return "arc-main low-main";
    }

    function arcClassGlow(count) {
      const v = classifyVolume(count);
      if (v === "high") return "arc-glow high-glow";
      if (v === "med") return "arc-glow med-glow";
      return "arc-glow low-glow";
    }

    // Convert migration rows into geo LineStrings
    function buildArcGeoData(rows) {
      return rows
        .map((d) => {
          const src = countryCoords[d.origin];
          const dst = countryCoords[d.destination];
          if (!src || !dst) return null;
          return {
            type: "LineString",
            coordinates: [
              [src[1], src[0]],
              [dst[1], dst[0]],
            ],
            count: d.count,
            origin: d.origin,
            destination: d.destination,
          };
        })
        .filter(Boolean);
    }

    // Build many segments along great circle for smoother 3D feel
    function pathForArc(lineString) {
      const [start, end] = lineString.coordinates;
      const interpolate = d3.geoInterpolate(start, end);
      const coords = [];
      const steps = 80;
      for (let i = 0; i <= steps; i++) {
        coords.push(interpolate(i / steps));
      }
      return path({ type: "LineString", coordinates: coords });
    }

    // ==============================
    // DRAW ALL ARCS
    // ==============================
    function drawArcs() {
      const arcs = buildArcGeoData(filteredData);

      arcsBaseGroup.selectAll("path").remove();
      arcsMainGroup.selectAll("path").remove();
      arcsGlowGroup.selectAll("path").remove();

      // Base outline
      arcsBaseGroup
        .selectAll("path")
        .data(arcs)
        .enter()
        .append("path")
        .attr("class", (d) => arcClassBase(d.count))
        .attr("d", pathForArc);

      // Main line
      arcsMainGroup
        .selectAll("path")
        .data(arcs)
        .enter()
        .append("path")
        .attr("class", (d) => arcClassMain(d.count))
        .attr("d", pathForArc);

      // Glow segments (animated)
      const glow = arcsGlowGroup
        .selectAll("path")
        .data(arcs)
        .enter()
        .append("path")
        .attr("class", (d) => arcClassGlow(d.count))
        .attr("d", pathForArc);

      animateGlow(glow);
    }

    // ==============================
    // GLOW ANIMATION
    // ==============================
    function animateGlow(selection) {
      // This animates stroke-dashoffset to simulate motion
      selection.each(function (d, i) {
        const pathEl = this;
        const totalLength = pathEl.getTotalLength();

        d3.select(pathEl)
          .attr("stroke-dasharray", totalLength)
          .attr("stroke-dashoffset", totalLength)
          .transition()
          .delay(i * 200) // stagger
          .duration(2500)
          .ease(d3.easeLinear)
          .attr("stroke-dashoffset", 0)
          .on("end", function repeat() {
            if (!autoRotate) {
              // still run animation, but you can skip if you want
            }
            d3.select(this)
              .attr("stroke-dashoffset", totalLength)
              .transition()
              .duration(2500)
              .ease(d3.easeLinear)
              .attr("stroke-dashoffset", 0)
              .on("end", repeat);
          });
      });
    }

    // ==============================
    // DRAG & AUTO ROTATION
    // ==============================
    const drag = d3
      .drag()
      .on("start", function (event) {
        autoRotate = false;
        const r = projection.rotate();
        this._x0 = event.x;
        this._y0 = event.y;
        this._r0 = r;
      })
      .on("drag", function (event) {
        const r = this._r0;
        projection.rotate([
          r[0] + (event.x - this._x0) * 0.5,
          r[1] - (event.y - this._y0) * 0.5,
        ]);
        svg.selectAll("path").attr("d", path);
      });

    svg.call(drag);

    d3.timer((elapsed) => {
      if (autoRotate) {
        const r = projection.rotate();
        projection.rotate([
          r[0] + config.autoRotateSpeed * elapsed,
          r[1],
        ]);
        svg.selectAll("path").attr("d", path);
      }
    });

    // ==============================
    // PAUSE / PLAY BUTTON
    // ==============================
    const toggleBtn = document.getElementById("toggle-rotation");
    toggleBtn.addEventListener("click", () => {
      autoRotate = !autoRotate;
      toggleBtn.textContent = autoRotate ? "Pause rotation" : "Play rotation";
    });

    // ==============================
    // RETOOL-FRIENDLY API
    // ==============================
    function setData(data) {
      if (!data || !data.migrations) return;
      migrationData = data.migrations;
      filteredData = migrationData;
      drawArcs();
      console.log("‚úÖ Globe data loaded:", migrationData.length, "routes");
    }

    function filterCountry(country) {
      selectedCountry = country;
      if (!country) {
        filteredData = migrationData;
      } else {
        filteredData = migrationData.filter(
          (d) => d.origin === country || d.destination === country
        );
      }
      drawArcs();

      if (country && countryCoords[country]) {
        const [lat, lng] = countryCoords[country];
        const current = projection.rotate();
        d3.transition()
          .duration(1000)
          .tween("rotate", () => {
            const r = d3.interpolate(current, [-lng, -lat]);
            return (t) => {
              projection.rotate(r(t));
              svg.selectAll("path").attr("d", path);
            };
          });
      }
    }

    function selectRoute(origin, destination) {
      const filtered = migrationData.filter(
        (d) => d.origin === origin && d.destination === destination
      );
      if (!filtered.length) return;
      filteredData = filtered;
      drawArcs();

      const src = countryCoords[origin];
      const dst = countryCoords[destination];
      if (src && dst) {
        const midLat = (src[0] + dst[0]) / 2;
        const midLng = (src[1] + dst[1]) / 2;
        const current = projection.rotate();
        d3
          .transition()
          .duration(1000)
          .tween("rotate", () => {
            const r = d3.interpolate(current, [-midLng, -midLat]);
            return (t) => {
              projection.rotate(r(t));
              svg.selectAll("path").attr("d", path);
            };
          });
      }
    }

    function clearFilters() {
      selectedCountry = null;
      filteredData = migrationData;
      drawArcs();
    }

    function resetCamera() {
      const current = projection.rotate();
      d3.transition()
        .duration(1000)
        .tween("rotate", () => {
          const r = d3.interpolate(
            current,
            [config.horizontalTilt, config.verticalTilt]
          );
          return (t) => {
            projection.rotate(r(t));
            svg.selectAll("path").attr("d", path);
          };
        });
    }

    window.globeAPI = {
      loadData: setData,
      filterCountry,
      selectRoute,
      clearFilters,
      resetCamera,
      getState: () => ({
        selectedCountry,
        visibleRoutes: filteredData.length,
        totalRoutes: migrationData.length,
      }),
    };

    // Optional: PostMessage listener if you prefer that pattern
    window.addEventListener("message", (event) => {
      const { type, data, country, route } = event.data || {};
      if (type === "INIT_DATA") setData(data);
      if (type === "FILTER_COUNTRY") filterCountry(country);
      if (type === "SELECT_ROUTE" && route)
        selectRoute(route.origin, route.destination);
      if (type === "CLEAR_FILTER") clearFilters();
    });

    console.log("üåç D3 Globe ready. Use window.globeAPI from parent.");
  </script>
</body>
</html>
